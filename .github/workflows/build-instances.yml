# The following workflow was designed in an attempt to be idempotent as to not 
# waste storage space. Order of execution is also important, as the following 
# steps will run sequentially every time.

# When main branch is updated via direct push or PR, use packwiz to create a 
# new Curseforge instance, Modrinth instance, and a Prism instance (which will
# include a bundled packwiz-installer-bootstrap.jar), and upload as a build 
# artifact. Do not compile packwiz from source, just fetch the latest
# successful Go build from their repository.

name: Build client instance zips for all 3 compatible launcher types
on:
  
  push:
    # branches:
    #   - 'main'
    paths:
      - 'packs/*/client/**'
  pull_request:
    paths:
      - 'packs/*/client/**'
  # This adds a manual button that can be triggered in the UI
  workflow_dispatch:

# As I understand, all runners can ONLY be one of the runner virtual machine
# images supplied by GitHub (or a self-hosted runner but that's a much, MUCH
# later venture)
jobs:

  fetch-packwiz:
    name: Fetch latest Packwiz binary for use in following jobs
    runs-on: ubuntu-latest

    steps:
      - name: Find the latest successful Go build from the packwiz/packwiz repo
        id: get_latest_run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        # Actions outputs that you want to reuse must be exported like the last
        # line of this run block. Reference: 
        # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-output-parameter
        run: |
          set -euo pipefail
          LATEST_RUN_ID=$(\
            gh run list -R packwiz/packwiz --json workflowName,status,conclusion,createdAt,databaseId | \
            jq '.[] | select(.conclusion == "success" and .status == "completed" and .workflowName == "Go" )' | \
            jq -s 'sort_by(.createdAt) | last | .databaseId' \
          )
          echo "LATEST_RUN_ID: ${LATEST_RUN_ID}"
          echo "LATEST_RUN_ID=${LATEST_RUN_ID}" >> "$GITHUB_OUTPUT"

      - name: Check to see if there's a cached artifact already available for use
        id: check_cache
        uses: actions/cache/restore@v4.0.2
        with:
          # Check this key search pattern
          key: packwiz-${{ runner.os }}-${{ runner.arch }}-${{ steps.get_latest_run.outputs.LATEST_RUN_ID }}
          # If it exists, restore the file to this path. Reference:
          # https://docs.github.com/en/actions/learn-github-actions/variables
          path: ${{ github.workspace }}/packwiz

      - name: Download the Linux x86 64-bit binary artifact
        uses: actions/download-artifact@v4.1.7
        # Do this step only if we don't have the exact same version already cached
        if: steps.check_cache.outputs.cache-hit != 'true'
        with:
          name: Linux 64-bit x86
          github-token: ${{ secrets.GITHUB_TOKEN }}
          repository: packwiz/packwiz
          run-id: ${{ steps.get_latest_run.outputs.LATEST_RUN_ID }}
          path: ${{ github.workspace }}

      - name: Make packwiz binary executable
        # Do this step only if we don't have the exact same version already cached
        if: steps.check_cache.outputs.cache-hit != 'true'
        run: chmod +x ${{ github.workspace }}/packwiz || exit 1

      - name: Cache binary in the target dir
        id: cache_packwiz_binary
        uses: actions/cache/save@v4.0.2
        # Do this step only if we don't have the exact same version already cached
        if: steps.check_cache.outputs.cache-hit != 'true'
        with:
          path: ${{ github.workspace }}/packwiz
          key: packwiz-${{ runner.os }}-${{ runner.arch }}-${{ steps.get_latest_run.outputs.LATEST_RUN_ID }}
      
      - name: DEBUG - Echo output values
        run: |
          set -euo pipefail
          echo "cache_changed: ${{ !steps.check_cache.outputs.cache-hit }}"
          echo "latest_run_id: ${{ steps.get_latest_run.outputs.LATEST_RUN_ID }}"

    outputs:
      cache_changed: ${{ !steps.check_cache.outputs.cache-hit }} # when cache-hit true, there was no change, so return false
      latest_run_id: ${{ steps.get_latest_run.outputs.LATEST_RUN_ID }}

  find-changed-packs:
    name: Find and record changed modpack directories
    runs-on: ubuntu-latest

    steps:
      - name: Check out the repository to this job
        uses: actions/checkout@v4
        with:
          # Fetch HEAD and the commit right before HEAD
          # Between these two commits is where we're looking for changes
          fetch-depth: 2

      - name: Find changed modpack directories
        id: detect_changes
        run: |
          set -euo pipefail
          CHANGED_MODPACKS=$(\
            git diff --name-only HEAD~1 HEAD | \
            grep '^packs/' | \
            cut -d'/' -f2 | \
            sort | \
            uniq | \
            jq -R -s -c 'split("\n")[:-1]'
          )
          echo "CHANGED_MODPACKS: ${CHANGED_MODPACKS}"
          echo "CHANGED_MODPACKS=${CHANGED_MODPACKS}" >> "$GITHUB_OUTPUT"

    outputs:
      changed_modpacks: ${{ steps.detect_changes.outputs.CHANGED_MODPACKS }}
  
  # Use packwiz to create instances for the 3 supported launchers.
  # The Prism instance type includes an auto-update bootstrapper,
  # but doesn't actually build with Packwiz, so we don't need to pull it in.
  build-instance:
    name: Build [${{ matrix.instance_type }}] instance for [${{ matrix.pack_dir }}]
    runs-on: ubuntu-latest
    needs: [fetch-packwiz, find-changed-packs]

    # Using a matrix strategy because the instance generation commands are slightly similar
    strategy:
      matrix:
        instance_type: ['curseforge', 'modrinth', 'prism']
        pack_dir: ${{ fromJson(needs.find-changed-packs.outputs.changed_modpacks) }}

    steps:
      - name: Check out the repository to this job
        uses: actions/checkout@v4

      - name: Convert data from pack.toml to json with third-party yq action
        id: packtoml-to-json
        uses: mikefarah/yq@v4.44.2
        with:
          cmd: yq eval -oj '.' .\packs\${{ matrix.pack_dir }}\pack.toml

      - name: Extract name and version from previous step to individual workflow output values
        id: extracted-pack-info
        run: |
          set -euo pipefail
          PACK_NAME=$( echo '${{ steps.packtoml-to-json.outputs.result }}' | jq '.name' )
          PACK_VERSION=$( echo '${{ steps.packtoml-to-json.outputs.result }}' | jq '.version' )
          echo "PACK_NAME: ${PACK_NAME}"
          echo "PACK_VERSION: ${PACK_VERSION}"
          echo "PACK_NAME=${PACK_NAME}" >> "$GITHUB_OUTPUT"
          echo "PACK_VERSION=${PACK_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Restore cached binary to use in building ${{ matrix.instance_type }} instance
        uses: actions/cache/restore@v4.0.2
        if: matrix.instance_type != 'prism'
        with:
          path: ${{ github.workspace }}/packwiz
          key: packwiz-${{ runner.os }}-${{ runner.arch }}-${{ needs.fetch-packwiz.outputs.latest_run_id }}

      - name: Export instances from the source repository to ${{ matrix.instance_type }} with packwiz
        if: matrix.instance_type != 'prism'
        run: ${{ github.workspace }}/packwiz ${{ matrix.instance_type }} export --pack-file ./packs/${{ matrix.pack_dir }}/pack.toml --yes || exit 1

      - name: Upload exported instances as build artifacts
        uses: actions/upload-artifact@v4.3.4
        with:
          name: ${{ steps.extracted-pack-info.outputs.PACK_NAME }} (for ${{ matrix.instance_type }})
          path: ${{ steps.extracted-pack-info.outputs.PACK_NAME }}-${{ steps.extracted-pack-info.outputs.PACK_VERSION }}.*
